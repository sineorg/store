name: Add Theme
on:
  issues:
    types: [opened]

jobs:
  addThemePR:
    permissions:
      contents: write
      issues: write
      pull-requests: write
    name: Add a theme
    runs-on: ubuntu-latest
    if: startsWith(github.event.issue.title, '[add-theme]:')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Debug GITHUB_TOKEN permissions
        run: |
          echo "DEBUG: Checking GITHUB_TOKEN presence"
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "ERROR: GITHUB_TOKEN is not set"
          else
            echo "DEBUG: GITHUB_TOKEN is set (length: ${#GITHUB_TOKEN})"
            curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                 -H "Accept: application/vnd.github.v3+json" \
                 https://api.github.com/rate_limit | jq '.resources | { core: .core, pull_requests: .pulls }'
          fi

      - name: Verify close-issue version
        run: |
          echo "DEBUG: Checking available releases for peter-evans/close-issue"
          curl -s -H "Accept: application/vnd.github.v3+json" \
               https://api.github.com/repos/peter-evans/close-issue/releases | jq '[.[] | {tag_name: .tag_name, published_at: .published_at}]'
          echo "DEBUG: Using peter-evans/close-issue@v3 (latest stable version)"

      - name: Parse issue
        id: issue-parser
        uses: stefanbuck/github-issue-parser@v3
        with:
          template-path: .github/ISSUE_TEMPLATE/add-theme.yml

      - name: Export parsed payload into variables
        id: export
        run: |
          echo "THEME_HOMEPAGE=${{ fromJson(steps.issue-parser.outputs.jsonString)['homepage'] }}" >> $GITHUB_ENV
          echo "THEME_AUTHOR=${{ github.event.issue.user.login }}" >> $GITHUB_ENV
          echo "THEME_NAME=$(echo '${{ github.event.issue.title }}' | sed 's/^\[add-theme\]://' | xargs)" >> $GITHUB_ENV
          echo "THEME_JS_FILES=${{ fromJson(steps.issue-parser.outputs.jsonString)['js'] }}" >> $GITHUB_ENV

      - name: Create ownership check script
        run: |
          cat << 'EOF' > check_ownership.py
          import re
          import sys

          def check_ownership(homepage, issue_creator):
              pattern = r'github\.com/([^/]+)/([^/]+)'
              match = re.search(pattern, homepage)
              if not match:
                  print("Error: Invalid GitHub repository URL", file=sys.stderr)
                  sys.exit(1)
              owner, _ = match.groups()
              
              if owner.lower() != issue_creator.lower():
                  print(f"Error: You must be the owner of the repository ({owner}) to add a theme.", file=sys.stderr)
                  sys.exit(2)

          if __name__ == "__main__":
              check_ownership("${{ env.THEME_HOMEPAGE }}", "${{ env.THEME_AUTHOR }}")
          EOF

      - name: Run ownership check
        id: ownership-check
        run: |
          python check_ownership.py > ownership_output.txt 2> error.log
          if [ $? -ne 0 ]; then
            echo "OWNERSHIP_FAILED=true" >> $GITHUB_ENV
          fi

      - name: Capture ownership output
        if: env.OWNERSHIP_FAILED == 'true'
        run: |
          echo "OWNERSHIP_MESSAGE=$(cat ownership_output.txt 2>/dev/null || echo 'No output available')" >> $GITHUB_ENV
          ERROR_LOG=$(cat error.log 2>/dev/null || echo "No error details available")
          echo "ERROR_OUTPUT=Error in ownership check: $ERROR_LOG" >> $GITHUB_ENV

      - name: Close issue for ownership failure
        if: env.OWNERSHIP_FAILED == 'true'
        uses: peter-evans/close-issue@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          comment: |
            # Theme submission not authorized

            There was an issue processing your theme submission:

            > ${{ env.OWNERSHIP_MESSAGE || env.ERROR_OUTPUT }}

            Please ensure you own the repository specified in the homepage URL. If you believe this is an error, contact the maintainers or review the workflow logs.

      - name: Create duplicate check script
        if: env.OWNERSHIP_FAILED != 'true'
        run: |
          cat << 'EOF' > check_duplicate.py
          import json
          import re
          import urllib.request
          import os
          import sys

          def get_theme_id(homepage):
              pattern = r'github\.com/([^/]+)/([^/]+)'
              match = re.search(pattern, homepage)
              if not match:
                  print("Error: Invalid GitHub repository URL", file=sys.stderr)
                  raise ValueError("Invalid GitHub repository URL")
              owner, repo = match.groups()
              
              theme_json_url = f"https://raw.githubusercontent.com/{owner}/{repo}/main/theme.json"
              try:
                  with urllib.request.urlopen(theme_json_url) as response:
                      theme_data = json.loads(response.read().decode())
              except urllib.error.HTTPError as e:
                  print(f"Error: Failed to fetch theme.json: HTTP {e.code} {e.reason}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: HTTP {e.code} {e.reason}")
              except urllib.error.URLError as e:
                  print(f"Error: Failed to fetch theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: {str(e)}")
              except json.JSONDecodeError as e:
                  print(f"Error: Invalid JSON in theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Invalid JSON in theme.json: {str(e)}")
              
              theme_id = theme_data.get("id")
              if not theme_id:
                  print("Error: theme.json must contain 'id' property", file=sys.stderr)
                  raise ValueError("theme.json must contain 'id' property")
              return theme_id

          def check_duplicate_prs(theme_id):
              repo = "${{ github.repository }}"
              api_url = f"https://api.github.com/repos/{repo}/pulls?state=open"
              token = os.getenv('GITHUB_TOKEN')
              if not token:
                  print("Error: GITHUB_TOKEN is not set. Ensure the workflow has access to secrets.GITHUB_TOKEN and repository permissions allow Actions.", file=sys.stderr)
                  raise ValueError("GITHUB_TOKEN is not set")
              headers = {
                  "Authorization": f"Bearer {token}",
                  "Accept": "application/vnd.github.v3+json"
              }
              
              try:
                  req = urllib.request.Request(api_url, headers=headers)
                  with urllib.request.urlopen(req) as response:
                      prs = json.loads(response.read().decode())
              except urllib.error.HTTPError as e:
                  print(f"Error: Failed to fetch PRs: HTTP {e.code} {e.reason}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch PRs: HTTP {e.code} {e.reason}")
              except urllib.error.URLError as e:
                  print(f"Error: Failed to fetch PRs: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch PRs: {str(e)}")
              except json.JSONDecodeError as e:
                  print(f"Error: Invalid JSON in API response: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Invalid JSON in API response: {str(e)}")
              
              for pr in prs:
                  pr_number = pr["number"]
                  pr_state = pr["state"]
                  if pr_state != "open":
                      continue
                  files_url = f"https://api.github.com/repos/{repo}/pulls/{pr_number}/files"
                  try:
                      req = urllib.request.Request(files_url, headers=headers)
                      with urllib.request.urlopen(req) as response:
                          files = json.loads(response.read().decode())
                  except Exception as e:
                      print(f"Error: Failed to fetch files for PR #{pr_number}: {str(e)}", file=sys.stderr)
                      continue
                  
                  for file in files:
                      if file["filename"] == "data/marketplace.json":
                          patch = file.get("patch", "")
                          pattern = rf'"\s*{re.escape(theme_id)}\s*"\s*:\s*"[^"]+"'
                          if re.search(pattern, patch):
                              return pr_number, pr["html_url"]
              return None, None

          if __name__ == "__main__":
              try:
                  theme_id = get_theme_id("${{ env.THEME_HOMEPAGE }}")
                  pr_number, pr_url = check_duplicate_prs(theme_id)
                  if pr_number:
                      print(f"DUPLICATE_FOUND=Theme already submitted in PR #{pr_number}: {pr_url}")
                  else:
                      print("No duplicates found")
              except ValueError as e:
                  print(f"Error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
              except Exception as e:
                  print(f"Error: Unexpected error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
          EOF

      - name: Run duplicate check
        if: env.OWNERSHIP_FAILED != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python check_duplicate.py > duplicate_output.txt 2> error.log
          if [ $? -ne 0 ]; then
            echo "DUPLICATE_CHECK_FAILED=true" >> $GITHUB_ENV
          fi

      - name: Capture duplicate output
        if: env.OWNERSHIP_FAILED != 'true'
        run: |
          DUPLICATE_OUTPUT=$(cat duplicate_output.txt 2>/dev/null | grep -v "DEBUG:" || echo "No output available")
          ERROR_LOG=$(cat error.log 2>/dev/null | grep -v "DEBUG:" || echo "No error details available")
          if grep -q "DUPLICATE_FOUND=" duplicate_output.txt; then
            echo "DUPLICATE_FOUND=true" >> $GITHUB_ENV
            echo "DUPLICATE_MESSAGE=$DUPLICATE_OUTPUT" >> $GITHUB_ENV
          elif [ "$DUPLICATE_CHECK_FAILED" = "true" ]; then
            ERROR_LOG_SANITIZED=$(echo "$ERROR_LOG" | tr -d '\n\r' | sed 's/[^a-zA-Z0-9:._-]/ /g')
            echo "DUPLICATE_MESSAGE=Error processing theme: $ERROR_LOG_SANITIZED" >> $GITHUB_ENV
          else
            echo "DUPLICATE_MESSAGE=No duplicates found" >> $GITHUB_ENV
          fi

      - name: Close issue for duplicate submission
        if: env.OWNERSHIP_FAILED != 'true' && (env.DUPLICATE_FOUND == 'true' || env.DUPLICATE_CHECK_FAILED == 'true')
        uses: peter-evans/close-issue@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          comment: |
            # Theme submission issue

            Sorry, there was an issue processing your theme submission:

            > ${{ env.DUPLICATE_MESSAGE }}

            If this is a duplicate, please check existing open pull requests. Otherwise, verify your homepage URL is in the format 'https://github.com/owner/repo' and your theme.json contains a valid 'id' property. If you believe this is an error, contact the maintainers or review the workflow logs.

      - name: Create existing theme check script
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true'
        run: |
          cat << 'EOF' > check_existing.py
          import json
          import re
          import urllib.request
          import sys

          def get_theme_id(homepage):
              pattern = r'github\.com/([^/]+)/([^/]+)'
              match = re.search(pattern, homepage)
              if not match:
                  print("Error: Invalid GitHub repository URL", file=sys.stderr)
                  raise ValueError("Invalid GitHub repository URL")
              owner, repo = match.groups()
              
              theme_json_url = f"https://raw.githubusercontent.com/{owner}/{repo}/main/theme.json"
              try:
                  with urllib.request.urlopen(theme_json_url) as response:
                      theme_data = json.loads(response.read().decode())
              except urllib.error.HTTPError as e:
                  print(f"Error: Failed to fetch theme.json: HTTP {e.code} {e.reason}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: HTTP {e.code} {e.reason}")
              except urllib.error.URLError as e:
                  print(f"Error: Failed to fetch theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: {str(e)}")
              except json.JSONDecodeError as e:
                  print(f"Error: Invalid JSON in theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Invalid JSON in theme.json: {str(e)}")
              
              theme_id = theme_data.get("id")
              if not theme_id:
                  print("Error: theme.json must contain 'id' property", file=sys.stderr)
                  raise ValueError("theme.json must contain 'id' property")
              return theme_id

          def check_existing_theme(theme_id):
              try:
                  with open("data/marketplace.json", "r") as f:
                      data = json.load(f)
              except Exception as e:
                  print(f"Error: Failed to read data/marketplace.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Failed to read data/marketplace.json: {str(e)}")
              
              if theme_id in data:
                  return f"Theme with ID '{theme_id}' is already included in the marketplace"
              return None

          if __name__ == "__main__":
              try:
                  theme_id = get_theme_id("${{ env.THEME_HOMEPAGE }}")
                  existing_message = check_existing_theme(theme_id)
                  if existing_message:
                      print(f"EXISTING_FOUND={existing_message}")
                  else:
                      print("No existing theme found")
              except ValueError as e:
                  print(f"Error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
              except Exception as e:
                  print(f"Error: Unexpected error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
          EOF

      - name: Run existing theme check
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true'
        run: |
          python check_existing.py > existing_output.txt 2> error.log
          if [ $? -ne 0 ]; then
            echo "EXISTING_CHECK_FAILED=true" >> $GITHUB_ENV
          fi

      - name: Capture existing theme output
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true'
        run: |
          EXISTING_OUTPUT=$(cat existing_output.txt 2>/dev/null | grep -v "DEBUG:" || echo "No output available")
          ERROR_LOG=$(cat error.log 2>/dev/null | grep -v "DEBUG:" || echo "No error details available")
          if grep -q "EXISTING_FOUND=" existing_output.txt; then
            echo "EXISTING_FOUND=true" >> $GITHUB_ENV
            echo "EXISTING_MESSAGE=$EXISTING_OUTPUT" >> $GITHUB_ENV
          elif [ "$EXISTING_CHECK_FAILED" = "true" ]; then
            ERROR_LOG_SANITIZED=$(echo "$ERROR_LOG" | tr -d '\n\r' | sed 's/[^a-zA-Z0-9:._-]/ /g')
            echo "EXISTING_MESSAGE=Error processing theme: $ERROR_LOG_SANITIZED" >> $GITHUB_ENV
          else
            echo "EXISTING_MESSAGE=No existing theme found" >> $GITHUB_ENV
          fi

      - name: Close issue for existing theme
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && (env.EXISTING_FOUND == 'true' || env.EXISTING_CHECK_FAILED == 'true')
        uses: peter-evans/close-issue@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          comment: |
            # Theme already exists

            Sorry, there was an issue processing your theme submission:

            > ${{ env.EXISTING_MESSAGE }}

            This may be because the theme is already included in the marketplace. Please check the marketplace in data/marketplace.json, verify your homepage URL is in the format 'https://github.com/owner/repo', and ensure your theme.json contains a valid 'id' property. If you believe this is an error, contact the maintainers or review the workflow logs.

      - name: Create JS file download script
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        run: |
          cat << 'EOF' > download_js_files.py
          import json
          import re
          import urllib.request
          import urllib.parse
          import os
          import sys

          def get_theme_id(homepage):
              pattern = r'github\.com/([^/]+)/([^/]+)'
              match = re.search(pattern, homepage)
              if not match:
                  print("Error: Invalid GitHub repository URL", file=sys.stderr)
                  raise ValueError("Invalid GitHub repository URL")
              owner, repo = match.groups()
              
              theme_json_url = f"https://raw.githubusercontent.com/{owner}/{repo}/main/theme.json"
              try:
                  with urllib.request.urlopen(theme_json_url) as response:
                      theme_data = json.loads(response.read().decode())
              except urllib.error.HTTPError as e:
                  print(f"Error: Failed to fetch theme.json: HTTP {e.code} {e.reason}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: HTTP {e.code} {e.reason}")
              except urllib.error.URLError as e:
                  print(f"Error: Failed to fetch theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: {str(e)}")
              except json.JSONDecodeError as e:
                  print(f"Error: Invalid JSON in theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Invalid JSON in theme.json: {str(e)}")
              
              theme_id = theme_data.get("id")
              if not theme_id:
                  print("Error: theme.json must contain 'id' property", file=sys.stderr)
                  raise ValueError("theme.json must contain 'id' property")
              return theme_id

          def validate_github_raw_url(url):
              """Validate that the URL is a raw GitHub URL"""
              if not url.strip():
                  return False
              pattern = r'^https://raw\.githubusercontent\.com/[^/]+/[^/]+/[^/]+/.*\.js$'
              return bool(re.match(pattern, url.strip()))

          def get_filename_from_url(url):
              """Extract filename from URL"""
              parsed_url = urllib.parse.urlparse(url.strip())
              return os.path.basename(parsed_url.path)

          def download_js_files():
              js_files_input = "${{ env.THEME_JS_FILES }}"
              homepage = "${{ env.THEME_HOMEPAGE }}"
              
              # Get theme ID
              theme_id = get_theme_id(homepage)
              
              # Skip if no JS files specified
              if not js_files_input or js_files_input.strip() == "":
                  print("No JS files specified, skipping download")
                  return
              
              # Parse comma-separated URLs
              js_urls = [url.strip() for url in js_files_input.split(',') if url.strip()]
              
              if not js_urls:
                  print("No valid JS file URLs found, skipping download")
                  return
              
              # Create mods directory structure
              mods_dir = f"data/mods/{theme_id}"
              os.makedirs(mods_dir, exist_ok=True)
              
              downloaded_files = []
              
              for url in js_urls:
                  if not validate_github_raw_url(url):
                      print(f"Error: Invalid GitHub raw URL: {url}", file=sys.stderr)
                      raise ValueError(f"Invalid GitHub raw URL: {url}")
                  
                  filename = get_filename_from_url(url)
                  if not filename.endswith('.js'):
                      print(f"Error: File must have .js extension: {filename}", file=sys.stderr)
                      raise ValueError(f"File must have .js extension: {filename}")
                  
                  file_path = os.path.join(mods_dir, filename)
                  
                  try:
                      print(f"Downloading {url} to {file_path}")
                      with urllib.request.urlopen(url) as response:
                          content = response.read()
                      
                      with open(file_path, 'wb') as f:
                          f.write(content)
                      
                      downloaded_files.append(filename)
                      print(f"Successfully downloaded: {filename}")
                      
                  except urllib.error.HTTPError as e:
                      print(f"Error: Failed to download {url}: HTTP {e.code} {e.reason}", file=sys.stderr)
                      raise ValueError(f"Failed to download {url}: HTTP {e.code} {e.reason}")
                  except urllib.error.URLError as e:
                      print(f"Error: Failed to download {url}: {str(e)}", file=sys.stderr)
                      raise ValueError(f"Failed to download {url}: {str(e)}")
                  except Exception as e:
                      print(f"Error: Unexpected error downloading {url}: {str(e)}", file=sys.stderr)
                      raise ValueError(f"Unexpected error downloading {url}: {str(e)}")
              
              if downloaded_files:
                  print(f"Downloaded {len(downloaded_files)} JS files to {mods_dir}/")
                  print(f"Files: {', '.join(downloaded_files)}")

          if __name__ == "__main__":
              try:
                  download_js_files()
              except ValueError as e:
                  print(f"Error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
              except Exception as e:
                  print(f"Error: Unexpected error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
          EOF

      - name: Download JS files
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        run: |
          python download_js_files.py > js_download_output.txt 2> error.log
          if [ $? -ne 0 ]; then
            echo "JS_DOWNLOAD_FAILED=true" >> $GITHUB_ENV
          fi

      - name: Handle JS download failure
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true' && env.JS_DOWNLOAD_FAILED == 'true'
        run: |
          ERROR_LOG=$(cat error.log 2>/dev/null | grep -v "DEBUG:" || echo "No error details available")
          ERROR_LOG_SANITIZED=$(echo "$ERROR_LOG" | tr -d '\n\r' | sed 's/[^a-zA-Z0-9:._-]/ /g')
          echo "JS_ERROR_MESSAGE=Error downloading JS files: $ERROR_LOG_SANITIZED" >> $GITHUB_ENV

      - name: Close issue for JS download failure
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true' && env.JS_DOWNLOAD_FAILED == 'true'
        uses: peter-evans/close-issue@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          comment: |
            # Error downloading JS files

            Sorry, there was an error processing your JS files:

            > ${{ env.JS_ERROR_MESSAGE }}

            Please ensure all JS file URLs are valid raw GitHub URLs in the format 'https://raw.githubusercontent.com/owner/repo/branch/path/file.js' and that the files are accessible. If you believe this is an error, contact the maintainers or review the workflow logs.

      - name: Create update script
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true' && env.JS_DOWNLOAD_FAILED != 'true'
        run: |
          cat << 'EOF' > update_marketplace.py
          import json
          import re
          import urllib.request
          import sys
          import os

          def get_repo_info(homepage):
              pattern = r'github\.com/([^/]+)/([^/]+)'
              match = re.search(pattern, homepage)
              if not match:
                  print("Error: Invalid GitHub repository URL", file=sys.stderr)
                  raise ValueError("Invalid GitHub repository URL")
              owner, repo = match.groups()
              
              theme_json_url = f"https://raw.githubusercontent.com/{owner}/{repo}/main/theme.json"
              try:
                  with urllib.request.urlopen(theme_json_url) as response:
                      theme_data = json.loads(response.read().decode())
              except urllib.error.HTTPError as e:
                  print(f"Error: Failed to fetch theme.json: HTTP {e.code} {e.reason}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: HTTP {e.code} {e.reason}")
              except urllib.error.URLError as e:
                  print(f"Error: Failed to fetch theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: {str(e)}")
              except json.JSONDecodeError as e:
                  print(f"Error: Invalid JSON in theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Invalid JSON in theme.json: {str(e)}")
              
              theme_id = theme_data.get("id")
              if not theme_id:
                  print("Error: theme.json must contain 'id' property", file=sys.stderr)
                  raise ValueError("theme.json must contain 'id' property")
              return theme_id, f"{owner}/{repo}"

          def update_marketplace():
              marketplace_file = "data/marketplace.json"
              os.makedirs("data", exist_ok=True)
              
              try:
                  with open(marketplace_file, "r") as f:
                      data = json.load(f)
              except FileNotFoundError:
                  data = {}
              except Exception as e:
                  print(f"Error: Failed to read {marketplace_file}: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Failed to read {marketplace_file}: {str(e)}")
              
              homepage = "${{ env.THEME_HOMEPAGE }}"
              theme_id, user_repo = get_repo_info(homepage)
              
              data[theme_id] = user_repo
              
              with open(marketplace_file, "w") as f:
                  json.dump(data, f, indent=2)

          if __name__ == "__main__":
              try:
                  update_marketplace()
              except ValueError as e:
                  print(f"Error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
              except Exception as e:
                  print(f"Error: Unexpected error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
          EOF

      - name: Run update script
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true' && env.JS_DOWNLOAD_FAILED != 'true'
        run: |
          python update_marketplace.py > update_output.txt 2> error.log
          if [ $? -ne 0 ]; then
            echo "UPDATE_FAILED=true" >> $GITHUB_ENV
          fi

      - name: Extract JS files from textarea
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        run: |
          JS_URLS="${{ fromJson(steps.issue-parser.outputs.jsonString)['js'] }}"
          echo "JS_URLS=$JS_URLS" >> $GITHUB_ENV
          echo "DEBUG: JS URLs from textarea: $JS_URLS"

      - name: Create JS files download script
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        run: |
          cat << 'EOF' > download_js_files.py
          import json
          import re
          import urllib.request
          import os
          import sys

          def get_theme_id(homepage):
              pattern = r'github\.com/([^/]+)/([^/]+)'
              match = re.search(pattern, homepage)
              if not match:
                  print("Error: Invalid GitHub repository URL", file=sys.stderr)
                  raise ValueError("Invalid GitHub repository URL")
              owner, repo = match.groups()
              
              theme_json_url = f"https://raw.githubusercontent.com/{owner}/{repo}/main/theme.json"
              try:
                  with urllib.request.urlopen(theme_json_url) as response:
                      theme_data = json.loads(response.read().decode())
              except urllib.error.HTTPError as e:
                  print(f"Error: Failed to fetch theme.json: HTTP {e.code} {e.reason}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: HTTP {e.code} {e.reason}")
              except urllib.error.URLError as e:
                  print(f"Error: Failed to fetch theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Failed to fetch theme.json: {str(e)}")
              except json.JSONDecodeError as e:
                  print(f"Error: Invalid JSON in theme.json: {str(e)}", file=sys.stderr)
                  raise ValueError(f"Invalid JSON in theme.json: {str(e)}")
              
              theme_id = theme_data.get("id")
              if not theme_id:
                  print("Error: theme.json must contain 'id' property", file=sys.stderr)
                  raise ValueError("theme.json must contain 'id' property")
              return theme_id

          def validate_github_raw_url(url):
              # Check if URL is a valid GitHub raw URL
              pattern = r'^https://raw\.githubusercontent\.com/[^/]+/[^/]+/[^/]+/.+\.js$'
              return re.match(pattern, url.strip()) is not None

          def extract_filename(url):
              # Extract filename from URL (last part after /)
              return url.strip().split('/')[-1]

          def download_js_files(js_urls_str, theme_id):
              if not js_urls_str or js_urls_str.strip() == "":
                  print("No JS files specified, skipping...")
                  return
              
              # Split by comma and clean up URLs
              js_urls = [url.strip() for url in js_urls_str.split(',') if url.strip()]
              
              if not js_urls:
                  print("No valid JS URLs found, skipping...")
                  return
              
              # Create mods directory structure
              mods_dir = f"data/mods/{theme_id}"
              os.makedirs(mods_dir, exist_ok=True)
              print(f"Created directory: {mods_dir}")
              
              downloaded_files = []
              
              for url in js_urls:
                  if not validate_github_raw_url(url):
                      print(f"Warning: Invalid GitHub raw URL format: {url}", file=sys.stderr)
                      continue
                  
                  filename = extract_filename(url)
                  file_path = os.path.join(mods_dir, filename)
                  
                  try:
                      print(f"Downloading {url} -> {file_path}")
                      with urllib.request.urlopen(url) as response:
                          content = response.read()
                      
                      with open(file_path, 'wb') as f:
                          f.write(content)
                      
                      downloaded_files.append(filename)
                      print(f"Successfully downloaded: {filename}")
                      
                  except urllib.error.HTTPError as e:
                      print(f"Error: Failed to download {url}: HTTP {e.code} {e.reason}", file=sys.stderr)
                      continue
                  except urllib.error.URLError as e:
                      print(f"Error: Failed to download {url}: {str(e)}", file=sys.stderr)
                      continue
                  except Exception as e:
                      print(f"Error: Unexpected error downloading {url}: {str(e)}", file=sys.stderr)
                      continue
              
              if downloaded_files:
                  print(f"Successfully downloaded {len(downloaded_files)} JS files: {', '.join(downloaded_files)}")
              else:
                  print("No JS files were successfully downloaded")

          if __name__ == "__main__":
              try:
                  homepage = "${{ env.THEME_HOMEPAGE }}"
                  js_urls = "${{ env.JS_URLS }}"
                  theme_id = get_theme_id(homepage)
                  download_js_files(js_urls, theme_id)
              except ValueError as e:
                  print(f"Error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
              except Exception as e:
                  print(f"Error: Unexpected error: {str(e)}", file=sys.stderr)
                  sys.exit(1)
          EOF

      - name: Download JS files
        if: env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        run: |
          python download_js_files.py > js_output.txt 2> js_error.log
          if [ $? -ne 0 ]; then
            echo "JS_DOWNLOAD_FAILED=true" >> $GITHUB_ENV
            cat js_error.log
          else
            cat js_output.txt
          fi

      - name: Export error output
        if: failure() && env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        run: |
          if [ -f error.log ]; then
            cat error.log
            ERROR_LOG=$(cat error.log 2>/dev/null | grep -v "DEBUG:" || echo "No error details available")
            echo "ERROR_OUTPUT=$ERROR_LOG" >> $GITHUB_ENV
          else
            echo "DEBUG: error.log not found"
            echo "ERROR_OUTPUT=Unknown error occurred, please check workflow logs" >> $GITHUB_ENV
          fi

      - name: Show error message
        if: failure() && env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        uses: peter-evans/close-issue@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          comment: |
            # Error adding theme

            Sorry, there was an error processing your theme submission:

            > ${{ env.ERROR_OUTPUT || 'Unknown error occurred, please check workflow logs' }}

            Please verify your homepage URL is in the format 'https://github.com/owner/repo' and your theme.json contains a valid 'id' property. If you believe this is an error, contact the maintainers or review the workflow logs.

      - name: Setup Git
        if: success() && env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create Pull Request
        if: success() && env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          add-paths: |
            data/marketplace.json
            data/mods/
          labels: staged
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Add theme: ${{ env.THEME_NAME }}"
          delete-branch: true
          title: "Add theme: ${{ env.THEME_NAME }}"
          body: |
            # Add theme: ${{ env.THEME_NAME }}

            This PR adds a new theme to the marketplace.

            ## Theme Details
            * **Name**: ${{ env.THEME_NAME }}
            * **Homepage**: ${{ env.THEME_HOMEPAGE }}
            * **Author**: @${{ env.THEME_AUTHOR }}
            
            ## JS Files
            JS files have been downloaded and placed in `data/mods/${{ env.THEME_NAME }}/` directory.
          branch: add-theme-${{ github.event.issue.number }}
          base: main

      - name: Debug Comment Issue
        if: success() && env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        run: |
          echo "DEBUG: Preparing to comment on issue"
          echo "DEBUG: THEME_NAME=${{ env.THEME_NAME }}"
          echo "DEBUG: GITHUB_TOKEN length=${#GITHUB_TOKEN}"
          echo "DEBUG: Comment content:"
          echo "# Thank you for your contribution! :tada:"
          echo "Your theme \"${{ env.THEME_NAME }}\" has been successfully submitted. The maintainers will review it and get back to you soon."
          echo "Here are some details about your submission:"
          echo "* Your theme has been requested into a new pull request."
          echo "* It has been created in the branch [add-theme-${{ github.event.issue.number }}](https://github.com/${{ github.repository }}/tree/add-theme-${{ github.event.issue.number }})."

      - name: Comment on Issue
        if: success() && env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        run: |
          curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -d "{\"body\": \"# Thank you for your contribution! :tada:\n\nYour theme \\\"${{ env.THEME_NAME }}\\\" has been successfully submitted. The maintainers will review it and get back to you soon.\n\nHere are some details about your submission:\n* Your theme has been requested into a new pull request.\n* It has been created in the branch [add-theme-${{ github.event.issue.number }}](https://github.com/${{ github.repository }}/tree/add-theme-${{ github.event.issue.number }}).\n* JS files (if any) have been downloaded and placed in the mods directory.\"}" \
            https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments > comment_response.txt
          if [ $? -eq 0 ]; then
            echo "DEBUG: Comment posted successfully"
            cat comment_response.txt
          else
            echo "ERROR: Failed to post comment"
            cat comment_response.txt
            echo "FALLBACK_MESSAGE=Failed to post success comment. Your theme '${{ env.THEME_NAME }}' was submitted, and a pull request was created. Please check the repository for details." >> $GITHUB_ENV
          fi

      - name: Fallback Comment on Issue
        if: success() && env.FALLBACK_MESSAGE != ''
        run: |
          curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -d "{\"body\": \"${{ env.FALLBACK_MESSAGE }}\"}" \
            https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments > fallback_comment_response.txt
          if [ $? -eq 0 ]; then
            echo "DEBUG: Fallback comment posted successfully"
            cat fallback_comment_response.txt
          else
            echo "ERROR: Failed to post fallback comment"
            cat fallback_comment_response.txt
          fi

      - name: Close Issue
        if: success() && env.OWNERSHIP_FAILED != 'true' && env.DUPLICATE_FOUND != 'true' && env.DUPLICATE_CHECK_FAILED != 'true' && env.EXISTING_FOUND != 'true' && env.EXISTING_CHECK_FAILED != 'true'
        uses: peter-evans/close-issue@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
